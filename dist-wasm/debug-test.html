<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Debug Test - Open Pages</title>
        <style>
            body {
                font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
                background: #0d1117;
                color: #f0f6fc;
                margin: 0;
                padding: 20px;
                line-height: 1.4;
            }
            .container {
                max-width: 900px;
                margin: 0 auto;
            }
            h1 {
                color: #58a6ff;
                text-align: center;
                border-bottom: 2px solid #21262d;
                padding-bottom: 10px;
            }
            .log {
                background: #161b22;
                border: 1px solid #30363d;
                border-radius: 6px;
                padding: 15px;
                margin: 20px 0;
                max-height: 400px;
                overflow-y: auto;
                font-size: 13px;
            }
            .log-entry {
                margin: 5px 0;
                padding: 5px 10px;
                border-radius: 3px;
            }
            .log-entry.info {
                background: #0969da20;
                color: #58a6ff;
            }
            .log-entry.success {
                background: #1a7f3720;
                color: #3fb950;
            }
            .log-entry.error {
                background: #da363620;
                color: #f85149;
            }
            .log-entry.warning {
                background: #d2930920;
                color: #f2cc60;
            }

            .step {
                background: #21262d;
                border-radius: 6px;
                padding: 15px;
                margin: 15px 0;
                border-left: 4px solid #58a6ff;
            }
            .step.success {
                border-left-color: #3fb950;
            }
            .step.error {
                border-left-color: #f85149;
            }

            .details {
                font-size: 12px;
                color: #8b949e;
                margin-top: 10px;
            }
            .paper-test {
                background: #0d1117;
                border: 1px solid #30363d;
                border-radius: 6px;
                padding: 15px;
                margin: 10px 0;
            }
            .paper-title {
                color: #58a6ff;
                font-weight: bold;
            }
            .paper-status {
                display: inline-block;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 11px;
                margin-top: 5px;
            }
            .status-working {
                background: #d2930920;
                color: #f2cc60;
            }
            .status-idea {
                background: #1a7f3720;
                color: #3fb950;
            }
            .status-completed {
                background: #58a6ff20;
                color: #58a6ff;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üîç Open Pages Debug Test</h1>
            <p>
                Testing each component step by step to identify the loading
                issue...
            </p>

            <div id="log" class="log">
                <div class="log-entry info">üöÄ Starting diagnostic test...</div>
            </div>

            <div id="steps"></div>

            <div id="results" style="display: none">
                <h2>üìä Test Results</h2>
                <div id="papers-display"></div>
            </div>
        </div>

        <script>
            const log = document.getElementById("log");
            const steps = document.getElementById("steps");
            const results = document.getElementById("results");
            const papersDisplay = document.getElementById("papers-display");

            function addLog(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement("div");
                entry.className = `log-entry ${type}`;
                entry.innerHTML = `[${timestamp}] ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            function addStep(title, content, type = "info") {
                const step = document.createElement("div");
                step.className = `step ${type}`;
                step.innerHTML = `
                <h3>${title}</h3>
                <div>${content}</div>
            `;
                steps.appendChild(step);
            }

            async function test1_BasicFileAccess() {
                addLog("üîç Test 1: Basic file accessibility", "info");

                try {
                    // Test main files exist
                    const files = [
                        "./sources.tar",
                        "./pkg/open_pages_processor.js",
                        "./pkg/open_pages_processor_bg.wasm",
                    ];

                    for (const file of files) {
                        const response = await fetch(file, { method: "HEAD" });
                        if (response.ok) {
                            addLog(
                                `‚úÖ ${file} - accessible (${response.status})`,
                                "success",
                            );
                        } else {
                            addLog(
                                `‚ùå ${file} - not accessible (${response.status})`,
                                "error",
                            );
                            throw new Error(
                                `Cannot access ${file}: ${response.status}`,
                            );
                        }
                    }

                    addStep(
                        "Step 1: File Access",
                        "All required files are accessible",
                        "success",
                    );
                    return true;
                } catch (error) {
                    addLog(
                        `‚ùå File access test failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Step 1: File Access",
                        `Failed: ${error.message}`,
                        "error",
                    );
                    return false;
                }
            }

            async function test2_SourcesContent() {
                addLog("üîç Test 2: Sources.tar content analysis", "info");

                try {
                    const response = await fetch("./sources.tar");
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const size = arrayBuffer.byteLength;
                    addLog(`‚úÖ Sources.tar loaded: ${size} bytes`, "success");

                    // Simple tar parsing
                    const uint8Array = new Uint8Array(arrayBuffer);
                    const files = [];
                    let offset = 0;

                    while (offset < uint8Array.length) {
                        const header = uint8Array.slice(offset, offset + 512);

                        // Check for end of archive
                        if (header.every((byte) => byte === 0)) break;

                        // Extract filename
                        let filename = "";
                        for (let i = 0; i < 100 && header[i] !== 0; i++) {
                            filename += String.fromCharCode(header[i]);
                        }

                        // Extract file size
                        let sizeStr = "";
                        for (let i = 124; i < 135 && header[i] !== 0; i++) {
                            sizeStr += String.fromCharCode(header[i]);
                        }
                        const fileSize = parseInt(sizeStr.trim(), 8) || 0;

                        if (filename && fileSize > 0) {
                            const content = new TextDecoder().decode(
                                uint8Array.slice(
                                    offset + 512,
                                    offset + 512 + fileSize,
                                ),
                            );
                            files.push({
                                filename,
                                size: fileSize,
                                content: content.substring(0, 200) + "...",
                            });
                            addLog(
                                `üìÑ Found: ${filename} (${fileSize} bytes)`,
                                "success",
                            );
                        }

                        offset += 512 + Math.ceil(fileSize / 512) * 512;
                    }

                    addStep(
                        "Step 2: Sources Content",
                        `Found ${files.length} files in archive:<br>` +
                            files
                                .map((f) => `‚Ä¢ ${f.filename} (${f.size} bytes)`)
                                .join("<br>"),
                        files.length > 0 ? "success" : "error",
                    );

                    return files;
                } catch (error) {
                    addLog(
                        `‚ùå Sources content test failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Step 2: Sources Content",
                        `Failed: ${error.message}`,
                        "error",
                    );
                    return [];
                }
            }

            async function test3_WebAssemblySupport() {
                addLog("üîç Test 3: WebAssembly support check", "info");

                try {
                    if (typeof WebAssembly === "undefined") {
                        throw new Error("WebAssembly not supported");
                    }

                    // Test basic WASM loading
                    const wasmResponse = await fetch(
                        "./pkg/open_pages_processor_bg.wasm",
                    );
                    const wasmBytes = await wasmResponse.arrayBuffer();
                    addLog(
                        `‚úÖ WASM binary loaded: ${wasmBytes.byteLength} bytes`,
                        "success",
                    );

                    // Try to compile
                    const module = await WebAssembly.compile(wasmBytes);
                    addLog("‚úÖ WASM module compiled successfully", "success");

                    addStep(
                        "Step 3: WebAssembly",
                        `WebAssembly is supported and WASM module compiles successfully`,
                        "success",
                    );
                    return true;
                } catch (error) {
                    addLog(
                        `‚ùå WebAssembly test failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Step 3: WebAssembly",
                        `Failed: ${error.message}`,
                        "error",
                    );
                    return false;
                }
            }

            async function test4_ModuleImport() {
                addLog("üîç Test 4: ES6 module import", "info");

                try {
                    // Test if we can import the module
                    const wasmModule = await import(
                        "./pkg/open_pages_processor.js"
                    );
                    addLog("‚úÖ ES6 module import successful", "success");

                    // Initialize WASM
                    await wasmModule.default();
                    addLog("‚úÖ WASM module initialized", "success");

                    // Check available exports
                    const exports = Object.keys(wasmModule);
                    addLog(
                        `‚úÖ Available exports: ${exports.join(", ")}`,
                        "success",
                    );

                    addStep(
                        "Step 4: Module Import",
                        `ES6 import successful. Available exports: ${exports.join(", ")}`,
                        "success",
                    );

                    return wasmModule;
                } catch (error) {
                    addLog(
                        `‚ùå Module import failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Step 4: Module Import",
                        `Failed: ${error.message}`,
                        "error",
                    );
                    return null;
                }
            }

            async function test5_PaperProcessing(wasmModule, files) {
                addLog("üîç Test 5: Paper processing", "info");

                try {
                    if (!wasmModule) {
                        throw new Error("WASM module not available");
                    }

                    if (files.length === 0) {
                        throw new Error("No files to process");
                    }

                    // Get the necessary functions
                    const { PaperProcessor, process_tar_archive } = wasmModule;

                    if (!PaperProcessor || !process_tar_archive) {
                        throw new Error(
                            "Required functions not found in WASM module",
                        );
                    }

                    // Load sources again for processing
                    const response = await fetch("./sources.tar");
                    const sourcesData = new Uint8Array(
                        await response.arrayBuffer(),
                    );

                    // Create processor
                    const processor = new PaperProcessor();
                    addLog("‚úÖ PaperProcessor created", "success");

                    // Process tar
                    const extractedFiles = process_tar_archive(sourcesData);
                    addLog(
                        `‚úÖ Extracted ${extractedFiles.length} files`,
                        "success",
                    );

                    // Process each file
                    extractedFiles.forEach((file) => {
                        const filename = file.filename.replace("papers/", "");
                        processor.process_paper(filename, file.content);
                        addLog(`üìù Processed: ${filename}`, "info");
                    });

                    // Get results
                    const papersJson = processor.get_papers_json();
                    const papers = JSON.parse(papersJson);
                    addLog(
                        `‚úÖ Generated ${papers.length} paper objects`,
                        "success",
                    );

                    // Display papers
                    if (papers.length > 0) {
                        papers.forEach((paper) => {
                            const paperDiv = document.createElement("div");
                            paperDiv.className = "paper-test";
                            paperDiv.innerHTML = `
                            <div class="paper-title">${paper.title || "Untitled"}</div>
                            <div class="paper-status status-${paper.status || "unknown"}">${paper.status || "unknown"}</div>
                            <div class="details">${paper.summary || "No summary"}</div>
                        `;
                            papersDisplay.appendChild(paperDiv);
                        });
                        results.style.display = "block";
                    }

                    addStep(
                        "Step 5: Paper Processing",
                        `Successfully processed ${papers.length} papers`,
                        "success",
                    );

                    return papers;
                } catch (error) {
                    addLog(
                        `‚ùå Paper processing failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Step 5: Paper Processing",
                        `Failed: ${error.message}`,
                        "error",
                    );
                    return [];
                }
            }

            async function runDiagnostics() {
                addLog("üöÄ Starting comprehensive diagnostics...", "info");

                // Environment info
                addLog(`üåê URL: ${window.location.href}`, "info");
                addLog(
                    `üñ•Ô∏è User Agent: ${navigator.userAgent.substring(0, 80)}...`,
                    "info",
                );
                addLog(
                    `üì± Viewport: ${window.innerWidth}x${window.innerHeight}`,
                    "info",
                );

                try {
                    // Test 1: File Access
                    const filesOk = await test1_BasicFileAccess();
                    if (!filesOk) return;

                    // Test 2: Sources Content
                    const files = await test2_SourcesContent();

                    // Test 3: WebAssembly Support
                    const wasmOk = await test3_WebAssemblySupport();
                    if (!wasmOk) return;

                    // Test 4: Module Import
                    const wasmModule = await test4_ModuleImport();

                    // Test 5: Paper Processing
                    if (wasmModule) {
                        const papers = await test5_PaperProcessing(
                            wasmModule,
                            files,
                        );

                        if (papers && papers.length > 0) {
                            addLog(
                                "üéâ All tests completed successfully!",
                                "success",
                            );
                            addStep(
                                "Final Result",
                                `‚úÖ All systems working correctly. ${papers.length} papers loaded and processed.`,
                                "success",
                            );
                        } else {
                            addLog(
                                "‚ö†Ô∏è Tests completed but no papers were processed",
                                "warning",
                            );
                            addStep(
                                "Final Result",
                                "‚ö†Ô∏è WASM is working but no papers were processed. Check paper content/format.",
                                "warning",
                            );
                        }
                    }
                } catch (error) {
                    addLog(
                        `üí• Diagnostic sequence failed: ${error.message}`,
                        "error",
                    );
                    addStep(
                        "Final Result",
                        `‚ùå Critical failure: ${error.message}`,
                        "error",
                    );
                }
            }

            // Start diagnostics when page loads
            document.addEventListener("DOMContentLoaded", () => {
                addLog("üìã Debug test page loaded", "success");
                setTimeout(runDiagnostics, 500);
            });

            // Global error handling
            window.addEventListener("error", (event) => {
                addLog(
                    `üö® Global error: ${event.error?.message || event.message}`,
                    "error",
                );
            });

            window.addEventListener("unhandledrejection", (event) => {
                addLog(
                    `üö® Unhandled rejection: ${event.reason?.message || event.reason}`,
                    "error",
                );
            });
        </script>
    </body>
</html>
