<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Open Pages by MoKa Reads</title>

        <!-- Disable all Cloudflare optimizations -->
        <meta name="cf-script-loader-disabled" content="true" />
        <meta name="cf-rocket-loader-disabled" content="true" />
        <meta http-equiv="Cache-Control" content="no-transform" />

        <!-- Fonts -->
        <link
            href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Merriweather:wght@400;700&display=swap"
            rel="stylesheet"
        />

        <!-- Font Awesome Icons -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
        />

        <!-- Stylesheets -->
        <link rel="stylesheet" href="dist/css/style.css" />
        <link
            rel="stylesheet"
            href="dist/css/theme-default.css"
            id="theme-stylesheet"
        />

        <style>
            .loading-indicator {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                z-index: 9999;
                color: #58a6ff;
                font-size: 1.2em;
            }

            .status-message {
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 10px;
                border-radius: 5px;
                font-family: monospace;
                font-size: 12px;
                z-index: 10000;
                max-width: 300px;
                word-wrap: break-word;
            }

            .status-success {
                background: #1a4a1a;
                color: #6bcf7f;
                border: 1px solid #6bcf7f;
            }

            .status-error {
                background: #4a1a1a;
                color: #ff6b6b;
                border: 1px solid #ff6b6b;
            }

            .status-info {
                background: #1a1a4a;
                color: #6bb6ff;
                border: 1px solid #6bb6ff;
            }

            .paper-card {
                background: var(--color-bg-card);
                border: 1px solid var(--color-border);
                border-radius: 8px;
                padding: 20px;
                margin: 15px 0;
                transition: transform 0.2s ease;
            }

            .paper-card:hover {
                transform: translateY(-2px);
                border-color: var(--color-primary);
            }

            .paper-title {
                color: var(--color-primary);
                font-size: 1.3em;
                margin-bottom: 10px;
                font-weight: bold;
            }

            .paper-status {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 15px;
                font-size: 0.8em;
                margin: 8px 0;
                text-transform: uppercase;
                font-weight: bold;
            }

            .status-working {
                background: var(--color-status-working-bg);
                color: var(--color-status-working-text);
            }

            .status-idea {
                background: var(--color-status-idea-bg);
                color: var(--color-status-idea-text);
            }

            .status-completed {
                background: var(--color-status-completed-bg);
                color: var(--color-status-completed-text);
            }

            .paper-summary {
                color: var(--color-text-muted);
                font-style: italic;
                margin-top: 10px;
            }

            .error-display {
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                z-index: 10000;
                background: rgba(255, 0, 0, 0.1);
                color: #ff6b6b;
                padding: 20px;
                border: 1px solid #ff6b6b;
                border-radius: 5px;
                font-family: monospace;
            }
        </style>
    </head>
    <body class="loading">
        <div class="loading-indicator">
            <i class="fas fa-spinner fa-spin fa-3x"></i>
            <p>Loading papers...</p>
        </div>

        <!-- Theme Selector -->
        <div class="theme-selector">
            <label for="theme-select">
                <i class="fas fa-palette"></i>
                <span>Theme:</span>
            </label>
            <select id="theme-select">
                <option value="default">Default</option>
                <option value="maple">Maple</option>
                <option value="moka">Moka</option>
            </select>
        </div>

        <!-- Header -->
        <header>
            <h1>ðŸ“– Open Pages ðŸ“–</h1>
            <p>
                Accessible academic research, promoting open knowledge and
                accelerating progress through collaboration
            </p>
        </header>

        <!-- Main Content -->
        <main class="container">
            <!-- Search and Filters -->
            <div class="filters-container">
                <div class="search-container">
                    <i class="fas fa-search"></i>
                    <input
                        type="text"
                        id="search-input"
                        class="search-input"
                        placeholder="Search by title, topic, or tag..."
                    />
                </div>

                <select id="category-filter" class="filter-select">
                    <option value="">All Categories</option>
                </select>

                <select id="status-filter" class="filter-select">
                    <option value="">All Statuses</option>
                    <option value="working">Working On</option>
                    <option value="idea">Idea</option>
                    <option value="completed">Completed</option>
                </select>

                <select id="sort-order" class="filter-select">
                    <option value="title-asc">Title (A-Z)</option>
                    <option value="title-desc">Title (Z-A)</option>
                    <option value="date-desc">Newest First</option>
                    <option value="date-asc">Oldest First</option>
                </select>
            </div>

            <!-- Paper List -->
            <div id="paper-list" class="paper-list">
                <!-- Papers will be loaded here -->
            </div>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                Open Pages is an initiative by
                <a href="https://mokareads.org" target="_blank">MoKa Reads</a>
            </p>
        </footer>

        <!-- Cloudflare Bypass Script -->
        <script data-cfasync="false" data-cf-settings="rocket=0">
            // Disable Cloudflare completely
            if (typeof window.CloudFlare !== "undefined") {
                window.CloudFlare.push(["rocket", "0"]);
            }

            let statusMessages = [];

            function showStatus(message, type = "info") {
                console.log(`[${type.toUpperCase()}] ${message}`);

                // Remove old status messages
                const oldMessages =
                    document.querySelectorAll(".status-message");
                oldMessages.forEach((msg) => msg.remove());

                // Add new status message
                const div = document.createElement("div");
                div.className = `status-message status-${type}`;
                div.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                document.body.appendChild(div);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                }, 5000);
            }

            function showError(title, message, details = null) {
                document.body.classList.remove("loading");
                document.body.classList.add("error");

                const errorDiv = document.createElement("div");
                errorDiv.className = "error-display";
                errorDiv.innerHTML = `
                <h2>${title}</h2>
                <p><strong>Error:</strong> ${message}</p>
                ${details ? `<details><summary>Technical Details</summary><pre>${details}</pre></details>` : ""}
                <button onclick="location.reload();" style="margin-top: 10px; padding: 5px 10px; background: #ff6b6b; color: white; border: none; border-radius: 3px;">Reload Page</button>
            `;
                document.body.appendChild(errorDiv);
            }

            function displayPapers(papers) {
                const paperList = document.getElementById("paper-list");
                if (!paperList) return;

                if (papers.length === 0) {
                    paperList.innerHTML =
                        '<p style="text-align: center; color: var(--color-text-muted);">No papers found.</p>';
                    return;
                }

                paperList.innerHTML = papers
                    .map(
                        (paper) => `
                <div class="paper-card">
                    <div class="paper-title">${paper.title || "Untitled"}</div>
                    <div class="paper-status status-${paper.status || "unknown"}">${paper.status || "unknown"}</div>
                    <div class="paper-summary">${paper.summary || "No summary available"}</div>
                </div>
            `,
                    )
                    .join("");
            }

            // Simple fallback approach - load papers directly without WASM
            async function loadPapersDirectly() {
                try {
                    showStatus("Loading papers directly...", "info");

                    // Try to fetch the sources.tar file and parse manually
                    const response = await fetch("./sources.tar");
                    if (!response.ok) {
                        throw new Error(
                            `Failed to fetch sources: ${response.status}`,
                        );
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    showStatus("Parsing tar file...", "info");

                    // Simple tar parser for our specific use case
                    const files = [];
                    let offset = 0;

                    while (offset < uint8Array.length) {
                        // Read tar header
                        const header = uint8Array.slice(offset, offset + 512);

                        // Check if we've reached the end (two null blocks)
                        if (header.every((byte) => byte === 0)) {
                            break;
                        }

                        // Extract filename (first 100 bytes, null-terminated)
                        const filenameBytes = header.slice(0, 100);
                        let filename = "";
                        for (
                            let i = 0;
                            i < filenameBytes.length && filenameBytes[i] !== 0;
                            i++
                        ) {
                            filename += String.fromCharCode(filenameBytes[i]);
                        }

                        // Extract file size (bytes 124-135, octal)
                        const sizeBytes = header.slice(124, 135);
                        let sizeStr = "";
                        for (
                            let i = 0;
                            i < sizeBytes.length && sizeBytes[i] !== 0;
                            i++
                        ) {
                            sizeStr += String.fromCharCode(sizeBytes[i]);
                        }
                        const size = parseInt(sizeStr.trim(), 8) || 0;

                        // Skip header
                        offset += 512;

                        // Read file content
                        if (size > 0 && filename.endsWith(".md")) {
                            const contentBytes = uint8Array.slice(
                                offset,
                                offset + size,
                            );
                            const content = new TextDecoder("utf-8").decode(
                                contentBytes,
                            );
                            files.push({ filename, content });
                        }

                        // Move to next file (files are padded to 512-byte boundaries)
                        offset += Math.ceil(size / 512) * 512;
                    }

                    showStatus(`Extracted ${files.length} files`, "success");

                    // Parse markdown files manually
                    const papers = [];
                    files.forEach((file) => {
                        try {
                            const content = file.content;
                            const frontmatterMatch = content.match(
                                /^---\n([\s\S]*?)\n---/,
                            );

                            if (frontmatterMatch) {
                                const frontmatter = frontmatterMatch[1];
                                const bodyContent = content.slice(
                                    frontmatterMatch[0].length,
                                );

                                // Simple YAML parsing for our specific fields
                                const title =
                                    (frontmatter.match(
                                        /title:\s*["\']?(.*?)["\']?\s*$/m,
                                    ) || [])[1] || "Untitled";
                                const status =
                                    (frontmatter.match(/status:\s*(\w+)/m) ||
                                        [])[1] || "unknown";

                                // Extract summary from ## Summary section
                                const summaryMatch = bodyContent.match(
                                    /## Summary\s*\n\n(.*?)(\n\n|$)/s,
                                );
                                const summary = summaryMatch
                                    ? summaryMatch[1].trim()
                                    : "No summary available";

                                papers.push({
                                    title: title.replace(/["\'"]/g, ""),
                                    status,
                                    summary,
                                    filename: file.filename,
                                });
                            }
                        } catch (err) {
                            console.warn(
                                `Failed to parse ${file.filename}:`,
                                err,
                            );
                        }
                    });

                    showStatus(
                        `Parsed ${papers.length} papers successfully`,
                        "success",
                    );

                    // Display the papers
                    displayPapers(papers);

                    // Remove loading state
                    document.body.classList.remove("loading");
                    document.body.classList.add("loaded");

                    showStatus("Application loaded successfully!", "success");
                } catch (error) {
                    console.error("Failed to load papers:", error);
                    showError(
                        "ðŸš¨ Failed to Load Papers",
                        error.message,
                        error.stack,
                    );
                }
            }

            // Initialize theme
            function initializeTheme() {
                const themeSelect = document.getElementById("theme-select");
                const themeLink = document.getElementById("theme-stylesheet");

                if (themeSelect && themeLink) {
                    const savedTheme =
                        localStorage.getItem("selectedTheme") || "default";
                    themeSelect.value = savedTheme;
                    themeLink.href = `dist/css/theme-${savedTheme}.css`;

                    themeSelect.addEventListener("change", (e) => {
                        const theme = e.target.value;
                        themeLink.href = `dist/css/theme-${theme}.css`;
                        localStorage.setItem("selectedTheme", theme);
                    });
                }
            }

            // Start the application
            document.addEventListener("DOMContentLoaded", () => {
                showStatus("Starting application...", "info");
                initializeTheme();
                loadPapersDirectly();
            });

            // Global error handling
            window.addEventListener("error", (event) => {
                console.error("Global error:", event.error);
                showStatus("Unexpected error occurred", "error");
            });

            window.addEventListener("unhandledrejection", (event) => {
                console.error("Unhandled promise rejection:", event.reason);
                showStatus("Promise error occurred", "error");
                event.preventDefault();
            });
        </script>
    </body>
</html>
